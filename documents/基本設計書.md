# 設計と構築の方針

一応、現時点での設計方針は抽象的なものにとどめ、そのための決まりなどは進めるにつれていく。一番大事なことは**気軽な更新と開発速度**とする。

よって、特に最初のうちはガンガン仕様を書き換えるし、言語の変更やフォルダ構成の変更もいとわないこととする。

## クリーンアーキテクチャ

非機能要件 1.を満たすため、クリーンアーキテクチャの考えを取り入れる。以下がその概要。
理解しきれていない or 間違った箇所もあるかもしれないが、その場合は適宜修正する。

なお、インフラについてはコンテナを使うことで依存を減らしているが、その一方で Docker には完全依存している状況にある。

1.  第 1 層 (DB, Web, UI...)
    自分が不介入な外部システムのレイヤー。外部 API、データベース、フレームワークなど外部システムそれ自体を指す。
    自分が書くコードは存在しない。

    例：DB、外部 API、UI など

    1. DB（Postgres）
    2. 外部連携
       1. JquantsAPI
       2. IMAP（Gmail SBI 約定メール）
       3. SBI 証券 ホームページ
    3. スプレッドシート

2.  第 2 層 (Controllers)
    外部システム依存のあるコードが書かれるレイヤー。自分の意図とは関係なく仕様変更やバージョンアップが行われる可能性がある外部 API、インフラ、フレームワークなどの影響を閉じ込めることが目的。
    判断基準は、**その外部システムを別のものに代替したときに変更しなければならないコードかどうか**。Postgres が SQLite に変わったとき、JquantsAPI が Yahoo Finance API に変わったときに変更が必要なコードは全てこのレイヤーに収める。逆に、変更が不要なコードはこのレイヤーに書かない。

    例：DB の CRUD 処理、外部 API のレスポンスの整形、 UI へのデータ出力など

    1. DB 操作
    2. 外部連携へのアクセス、または外部連携用の変換
       1. JquantsAPI へのリクエスト、レスポンスの整形等
       2. IMAP（Gmail SBI 約定メール）の取得、整形等
       3. スクレイピング（SBI 証券 ホームページ）、整形等
    3. スプレッドシート側から取得できる API

3.  第 3 層 (UseCases)
    一般的解釈だと外部に規定はされないかつビジネスロジックではないものがかかれるレイヤー。自分の解釈としては業務フローを書くレイヤー。仕事の方法、言い換えれば作業手順書に変更があったときの影響をこのレイヤーに留めることが目的。
    判断基準は外部システム・インフラの操作方法や業界知識・専門知識のような自分達の仕事で決定できる範囲外のものかどうか。

    今回のシステムの例だと、API の認証トークン自動更新はあくまで API 側の仕様なので第 2 層 (Controllers)に記述したが、銘柄一覧取得の自動更新は業務フローに含まれるとして第 3 層 (UseCases)に記述している。

    例：データ構造、バリデーション、取得>整形>出力の一連の処理フローなど

    1. データベースのスキーマ
    2. 各種データの型指定

4.  第 4 層 (Entities)
    ビジネスロジック（システムに担わせる専門知識部分）が書かれるレイヤー。システムとは無関係な仕様や処理（社会的なルール、決まった計算方法）をアプリケーションから切り離すことが目的。
    判断基準は、アプリケーションとしての仕様変更（機能の追加・改修）をした際に変更が必要なコードかどうか。

    例：PER, PBR, 自己資本比率, 配当の計算など

## マイクロサービスアーキテクチャ

非機能要件 2,3 を満たすため、マイクロサービスアーキテクチャの考えを取り入れる。

特に 2. を意識し、各機能をモジュール単位で開発・置き換えできるようにする。3. は最終的な達成目標とし、並列化は各モジュールが出来上がってきてから考える。優先度は低く、最初はモノリスのように開発する。
